# ☑️ 42\_비동기 프로그래밍

p.809~815

✍️ 2024.10.24(Thurs)

## ✅ 42.1\_동기 처리와 비동기 처리

> 함수 호출 → 함수 코드 평가 → 함수 실행 컨텍스트 생성 → 실행 컨텍스트 스택에 푸시 → 함수 코드 실행 <br/>
> → 함수 코드 실행 종료 → 함수 실행 컨텍스트가 실행 컨텍스트 스택에서 팝되어 제거 <br/>
> → 함수 실행 - 함수 코드 평가 과정에서 생성된 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되어야 함
>
> ⇒ 실행 컨텍스트 스택에 함수 실행 컨텍스트가 푸시되는 것은 함수 실행 시작 의미
>
> ‣ 호출된 순서대로 함수 실행 컨텍스트가 실행 컨텍스트에 푸시되기 때문에 함수 호출 순서대로 순차적 실행됨 <br/>
> ⇒ 함수 실행 순서는 실행 컨텍스트 스택으로 관리

👀 JS엔진은 단 하나의 실행 컨텍스트 스택을 가짐 (동시에 2개 이상의 함수를 동시에 실행 불가) <br/>
→ ‘실행 중인 실행 컨텍스트’를 제외한 모든 실행 컨텍스트는 모두 실행 대기 중인 태스크들! <br/>
→ 대기 중인 태스크들은 현재 실행중인 함수가 종료되면 실행 시작! <br/>
⇒ JS엔진은 1번에 1개의 태스크만 실행 가능한 싱글 스레드(single thread) 방식으로 동작

- `Single Thread` : 1번에 1개의 태스크만 실행 가능하므로 처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹(blocking; 작업 중단) 발생

- 동기(`synchronous`) 처리: 현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식

  - 👍 태스크를 순서대로 하나씩 처리 → 실행 순서 보장
  - 👎 태스크 종료까지 이후 태스크들이 블로킹됨

- 비동기(`asynchronous`) 처리: 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식
  - 👍 블로킹 발생 ❌
  - 👎 태스크 실행 순서 보장 ❌
  - 콜백 패턴 사용 - callback hell을 발생시켜 가독성 bad, 에러 예외 처리 곤란, 여러 개의 비동기 처리 한번에 처리 한계 존재
  - e.g. setTimeout, setInterval, HTTP 요청, 이벤트 핸들러

<br/>

## ✅ 42.2\_이벤트 루프와 태스크 큐

- JS는 싱글 스레드로 동작 → 1번에 1개의 태스크만 처리 가능 <br/>but, 여러 태스크가 동시에 처리되는 것처럼 느껴짐 <br/>
  ⇒ 이벤트 루프(event loop) : JS의 동시성(concurrency) 지원

- JS엔진

  - `call stack` : 소스코드 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택
    - 함수 호출 → 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행됨
    - JS엔진은 단 하나의 콜 스택 사용하므로 최상위 실행 컨텍스트가 종료되어 콜 스택에서 제거되기 전까진 다른 어떤 태스크도 실행되지 않음
  - `heap` : 객체가 저장되는 메모리 공간
    - 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체 참조
    - 구조화되어 있지 않음 (객체는 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간 크기를 런타임에 결정해야 하므로)

- 비동기 처리에서 소스코드 평가와 실행을 제외한 모든 처리는 JS엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당 <br/>
  ⇒ 브라우저 환경은 태스크 큐 & 이벤트 루프 제공

- `task queue` / `event queue` / `callback queue` <br/>
  : 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역
- `event loop` <br/>
  : 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인
  - IF 콜스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면, 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜스택으로 이동시킴 (`FIFO`; `First In First Out`) → 콜스택으로 이동한 함수는 실행됨 <br/>
    ⇒ 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작

⇒ 비동기 함수인 setTimeout의 콜백 함수는 태스크 큐에 푸시되어 대기하다가 콜 스택이 비게 되면, 즉 전역 코드 및 명시적으로 호출된 함수가 모두 종료하면 콜 스택에 푸시되어 실행됨

🖐️ JS는 싱글 스레드 방식으로 동작한다. 이때 싱글 스레드 방식으로 동작하는 것은 브라우저가 아니라 브라우저에 내장된 JS엔진이라는 것에 주의! <br/>
→ JS엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작!
