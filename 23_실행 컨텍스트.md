# ☑️ 23. 실행 컨텍스트

p.359~387

✍️ 2024.09.10(Tues) ~ 09.12(Thurs)

## ✅ 23.1\_소스코드의 타입

1. `전역 코드`: 전역에 존재하는 소스코드로, 전역에 정의된 함수, 클래스 등의 내부 코드는 포함하지 않음
   - 전역 변수 관리를 위해 최상위 스코프인 전역 스코프를 생성해야 함
   - var로 선언 및 함수 선언문으로 정의된 전역 함수를 전역 객체 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 함 <br/>
     ⇒ 전역 코드가 평가되면 전역 실행 컨텍스트 생성
2. `함수 코드`: 함수 내부에 존재하는 소스코드로, 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함하지 않음
   - 지역 스코프 생성 및 지역변수, 매개변수, arguments 객체 관리해야 함
   - 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 함 <br/>
     ⇒ 함수 코드가 평가되면 함수 실행 컨텍스트가 생성됨
3. `eval 코드`: 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드
   - strict mode에서 독자전인 스코프 생성 <br/>
     ⇒ eval 코드가 평가되면 eval 실행 컨텍스트가 생성됨
4. `모듈 코드`: 모듈 내부에 존재하는 소스코드로, 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않음
   - 모듈별로 독립적인 모듈 스코프 생성 <br/>
     ⇒ 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성됨

<br/>

## ✅ 23.2\_소스코드의 평가와 실행

- JS엔진은 소스코드를 2개의 과정인 <u>소스코드 평가</u> & <u>소스코드 실행</u> 과정으로 나누어 처리함

1. 소스코드 평가 (선언문) :
   1. 실행 컨텍스트 생성
   2. 선언문(변수, 함수 …)만 먼저 실행 → 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록
2. 소스코드 실행 (선언문 이외의 문) :
   1. 소스코드 평가 과정이 끝나면 선언문을 제외한 소스코드가 순차적으로 실행 시작 ⇒ 런타임 시작
   2. 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득함
   3. 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록

```jsx
// 1. 소스코드 평가 과정 - 변수 선언문 먼저 실행
// 변수 식별자 x는 실행 컨텍스트가 관리하는 스코프에 등록 & undefined로 초기화
var x;

// 2. 소스코드 실행 과정 - 변수 할당문만 실행
// 2-1. x 변수가 선언된 변수인지 먼저 확인 <= 실행 컨텍스트가 관리하는 스코프에 x 변수가 등록되어 있는지 확인
// 2-2. 만약 x 변수가 스코프에 등록이 되어 있다면
//      -> x 변수는 선언된 변수 = 소스코드 평가 과정에서 선언문이 실행되어 등록된 변수
//      -> 값을 할당하고, 할당 결과를 실행 컨텍스트에 등록하여 관리
x = 1;
```

<br/>

## ✅ 23.3\_실행 컨텍스트의 역할

```jsx
// 1. 전역 코드 평가
// 선언문만 먼저 실행 -> 생성된 전역 변수가 실행 컨텍스트가 관리하는 전역 스코프에 등록됨

// 2. 전역 코드 실행
// 런타임 시작 -> 전역 코드 순차적으로 실행 시작
// 전역 변수에 값 할당 & 함수 호출 -> 전역 코드 실행 일시 중단 -> 코드 실행 순서 변경 -> 함수 내부로 진입

// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 3. 함수 코드 평가
  // 매개변수와 지역 변수 선언문 먼저 실행
  // 생성된 매개변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록됨
  // 지역 변수처럼 사용 가능한 arguments 객체가 생성되어 지역 스코프에 등록 & this 바인딩 결정됨

  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 4. 런타임 시작 -> 함수 코드 순차적으로 실행 시작

  // 매개변수와 지역 변수에 값 할당 & console.log 메서드 호출
  // 식별자인 console을 스코프 체인을 통해 검색 (함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 함)
  // But, console 식별자는스코프 체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재
  // => 전역 객체 프로퍼티가 전역 스코프를 통해 검색 가능해야 함을 의미

  // log 프로퍼티르 console 객체의 프로토타입 체인을 통해 검색
  // console.log 메서드에 인수로 전달된 표현식 a+x+y가 평가됨 (a,x,y 식별자는 스코프 체인을 통해 검색)
  // console.log 메서드 실행 종료 -> 함수 코드 실행 과정 종료 -> 함수 호출 이전으로 back -> 전역 코드 계속 실행

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

> 스코프를 구분하여 식별자와 바인딩된 값이 관리되어야 함
>
> - 중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 함
> - 전역 객체의 프로퍼티도 전역 변수처럼 검색 가능해야 함
> - 함수 호출이 종료되면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드 구분하여 관리해야 함 <br/>
>   ⇒ 아래와 같은 스코프, 식별자, 코드 실행 순서 등의 관리가 필요함

> 1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 …)를 스코프를 구분하여 등록하고, 상태 변화를 지속적으로 관리 가능해야 함
> 2. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 함 <br/>
>    ⇒ 스코프 체인을 통해 상위 스코프로 이동하며, 식별자 검색 가능해야 함
> 3. 현재 실행 중인 코드의 실행 순서를 변경 가능해야 하며, 다시 되돌아갈 수 있어야 함 <br/>
>
> ⇒ 이 모든 것을 관리하는 것이 `실행 컨텍스트`

- `실행 컨텍스트` 란? <br/>
  소스코드를 실행하는 데 필요한 환경을 제공하고 코드 실행 결과를 실제로 관리하는 영역 <br/>
  ⇒ 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리됨

<br/>

- 식별자와 스코프 - 실행 컨텍스트의 렉시컬 환경으로 관리
- 코드 실행 순서 - 실행 컨텍스트 스택으로 관리

<br/>

## ✅ 23.4\_실행 컨텍스트 스택

> <b>‣ JS엔진 역할</b>
>
> 1. 전역 코드 평가 → 전역 실행 컨텍스트 생성
> 2. 함수가 호출되면 함수 코드 평가 → 함수 실행 컨텍스트 생성
>
> 👀 이 때 생성된 실행 컨텍스트는 스택(stack) 자료구조로 관리 = `실행 컨텍스트 스택` = `call stack`

```jsx
// 1. 전역 코드의 평가 & 실행
// JS엔진이 먼저 전역 코드 평가 -> 전역 실행 컨텍스트 생성 -> 실행 컨텍스트 스택에 푸시
// 전역 변수 x & 전역 함수 foo가 전역 실행 컨텍스트에 등록됨
// 이후, 전역 코드 실행 시작 -> 전역 변수 x에 값 할당 & 전역 함수 foo 호출

const x = 1;

// 2. foo 함수 코드의 평가와 실행
// 전역 함수 foo 호출 -> 전역 코드 실행 일시 중단 -> 코드 제어권이 foo 함수 내부로 이동
// JS엔진은 foo 함수 내부 함수 코드 평가 -> foo 함수 실행 컨텍스트 생성 -> 실행 컨텍스트 스택에 푸시
// foo 함수의 지역 변수 y & 중첩 함수 bar가 foo 함수 실행 컨텍스트에 등록됨
// 이후, foo 함수 코드 실행 시작 -> 지역 변수 y에 값 할당 & 중첩 함수 bar 호출

function foo() {
  const y = 2;

  // 3. bar 함수 코드의 평가와 실행
  // 중첩 함수 bar 호출 -> foo 함수 코드 실행 일시 중단 -> 코드 제어권이 bar 함수 내부로 이동
  // JS엔진은 bar 함수 내부 함수 코드 평가 -> bar 함수 실행 컨텍스트 생성 -> 실행 컨텍스트 스택에 푸시
  // bar 함수의 지역 변수 z가 bar 함수 실행 컨텍스트에 등록됨
  // 이후, bar 함수 코드 실행 시작 -> 지역 변수 z에 값 할당 & console.log 메서드 호출 -> bar 함수 종료

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }

  bar();
}

// 4. foo 함수 코드로 복귀
// bar 함수 종료 -> 코드 제어권이 다시 foo 함수로 이동
// JS엔진은 bar 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 팝하여 제거 -> foo 함수 종료

// 5. 전역 코드로 복귀
// foo 함수 종료 -> 코드 제어권이 다시 전역 코드로 이동
// JS엔진은 foo 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 팝하여 제거
// 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 팝되어 실행 컨텍스트 스택이 empty되도록!

foo(); // 6
```

👉 실행 컨텍스트 스택은 코드 실행 순서를 관리함

- 소스코드 평가 → 실행 컨텍스트 생성 & 실행 컨텍스트 스택의 최상위에 쌓임
- 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 항상 현재 실행 중인 코드의 실행 컨텍스트 <br/>
  = 실행 중인 실행 컨텍스트(`running execution context`)

<br/>

## ✅ 23.5\_렉시컬 환경

- `렉시컬 환경(Lexical Environment)`: <br/>
  식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트

> - 실행 컨텍스트 스택 - 코드 실행 순서 관리
> - 렉시컬 환경 - 스코프와 식별자 관리

- 렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프 생성 → 식별자를 키로 등록 & 식별자에 바인딩된 값 관리 <br/>
  ⇒ 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체!

- 실행 컨텍스트

  - `LexicalEnvironment` 컴포넌트 & `VariableEnvironment` 컴포넌트로 구성
    - 생성 초기 이 둘의 컴포넌트는 하나의 동일한 렉시컬 환경 참조

- 렉시컬 환경
  - `Environment Record` (환경 레코드)
    - 스코프에 포함된 식별자 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소
    - 소스코드 타입에 따라 관리하는 내용에 차이가 있음
  - `Outer Lexical Environment Reference` (외부 렉시컬 환경에 대한 참조)
    - 상위 스코프(외부 렉시컬 환경 ⇒ 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경)를 가리킴
    - 이를 통해 단방향 링크드 리스트인 스코프 체인 구현

<br/>

## ✅ 23.6\_실행 컨텍스트의 생성과 식별자 검색 과정

```jsx
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }

  bar(10);
}

foo(20); // 42
```

### 🔸 23.6.1\_전역 객체 생성

- 전역 객체는 전역 코드 평가 이전에 생성됨

  - 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체 추가
  - 동작 환경에 따라 클라이언트 사이드 Web API 또는 특정 환경을 위한 호스트 객체 포함
  - `Obejct.prototype` 상속받음 ⇒ 전역 객체도 프로토타입 체인의 일원!

    ```jsx
    window.toString(); // "[object Window]"

    window.__proto__.__proto__.__proto__.__proto__ === Object.prototype; // true
    ```

<br/>

### 🔸 23.6.2\_전역 코드 평가

- 소스코드 로드 → JS엔진은 전역 코드 평가

<b>‣ 전역 코드 평가 순서</b>

1.  전역 실행 컨텍스트(Global Execution Context) 실행

- empty 전역 실행 컨텍스트 생성 → 실행 컨텍스트 스택에 푸시
- 전역 실행 컨텍스트 = 실행 컨텍스트 스택의 최상위 = 실행 중인 실행 컨텍스트

2.  전역 렉시컬 환경 생성

- 전역 렉시컬 환경 생성 & 전역 실행 컨텍스트에 바인딩

  2.1. 전역 환경 레코드 생성

  - 전역 환경 레코드: 전역 렉시컬 환경 구성 컴포넌트

    - 전역 스코프(전역 변수 관리), 전역 객체의 빌트인 전역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체 제공

  - `var` vs `let`, `const` 선언 전역 변수를 구분하여 관리하기 위해 아래와 같이 구성

    2.1.1. `객체 환경 레코드` 생성

    - 전역 환경 레코드 구성 컴포넌트로, `BindingObject` 객체와 연결됨

    - `var`로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수가 전역 객체의 프로퍼티와 메서드가 되고, <br/>
      전역 객체를 가리키는 식별자(`window`) 없이 전역 객체의 프로퍼티 참조

    ```jsx
    // 선언 단계 & 초기화 단계 동시 진행
    // 전역 코드 평가 시점에 객체 환경 레코드에 바인딩된 BindingObject를 통해 전역 객체에 변수 식별자를 키로 등록
    // 암묵적으로 undefined 바인딩
    // var 로 선언한 변수는 코드 실행 단계에서 변수 선언문 이전에도 참조 가능 (이 때 값은 항상 undefined**)
    // => 변수 호이스팅이 발생하는 원인**
    var x = 1;
    const y = 2;

    // 함수 선언문으로 정의한 함수가 평가
    // -> 함수 이름과 동일한 이름의 식별자를 객체 환경 레코드에 바인딩도니 BindingObject를 통해 전역 객체에 키로 등록
    // 생성된 함수 객체 즉시 할당
    // => 함수 호이스팅 (함수 선언문 이전에 함수 선언문으로 정의한 함수 호출 가능)
    function foo (a) {
      ...
    }
    ```

    2.1.2. `선언적 환경 레코드` 생성

    - `let`, `const`로 선언한 전역 변수 관리 → 전역 객체 프로퍼티가 되지 않음
    - `const` 선언 변수 - 선언 단계 & 초기화 단계 분리되어 진행 <br/>

      - 초기화 단계 - 런타임에 실행 흐름이 변수 선언문에 도달하기 전까지 일시적 사각지대(`Temporal Dead Zone; TDZ`)에 빠지게 됨
      - 변수 호이스팅이 발생하긴 하지만, 런타임에 컨트롤이 변수 선언문에 도달하기 전까지 TDZ에 빠지기 때문에 참조 불가!

        ```jsx
        let foo = 1; // 전역 변수

        {
          // 변수 호이스팅이 발생하기 때문에 전역 변수를 참조해야 하는데
          // TDZ에 빠져 참조 에러 발생
          console.log(foo); // ReferenceError
          let foo = 2; // 지역 변수
        }
        ```

    2.2. this 바인딩

    - 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에 this 바인딩

      - 전역 코드에서 this - 전역 객체를 가리킴 → 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯엔 전역 객체 바인딩됨
      - 전역 코드에서 this 참조 → 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에 바인딩되어 있는 객체 반환됨

      ✋ this 바인딩은 전역 환경 레코드 & 함수 환경 레코드에만 존재 (객체 환경 레코드 & 선언적 환경 레코드엔 없음)

    2.3. 외부 렉시컬 환경에 대한 참조 결정

    - 현재 평가 중인 소스코드(전역 코드)를 포함하는 외부 소스코드의 렉시컬 환경 = 상위 스코프를 가리킴 → 단방향 링크드 리스트인 스코프 체인 구현
      - 전역 코드를 포함하는 소스코드는 없으므로 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 `null` 할당 <br/>
        ⇒ 전역 렉시컬 환경이 스코프 체인 종점에 존재함을 의미

### 🔸 23.6.3\_전역 코드 실행

- 변수 할당문 / 함수 호출문을 실행하려면 먼저 변수 또는 함수 이름이 선언된 식별자인지 확인해야 함
  - 선언되지 않는 식별자는 참조할 수 없으므로 → 할당/호출 불가하기 때문
- 식별자는 스코프가 다르면 같은 이름 가질 수 있음 <br/>
  ⇒ 다른 스코프이면 동일 이름 식별자가 여러 개 존재 가능 ⇒ 식별자 결정(identifier resolution) 필요
  - 식별자 결정을 위해 식별자를 검색할 땐 실행 중인 실행 컨텍스트에서 식별자 검색 시작
    - 선언된 식별자는 실행 컨텍스트의 렉시컬 환경의 환경 레코드에 등록되어 있음

⇒ 실행 컨텍스트는 소스코드 실행을 위해 필요한 환경을 제공하고 코드 실행 결과를 실제 관리하는 영역!

### 🔸 23.6.4_foo 함수 코드 평가

- foo 함수 호출 → 전역 코드 실행 일시 중단 → foo 함수 내부로 코드 제어권 이동 → 함수 코드 평가 시작

<b>‣ 함수 코드 평가</b>

1.  함수 실행 컨텍스트 생성
    - 생성된 함수 실행 컨텍스트는 함수 렉시컬 환경이 완성된 다음 실행 컨텍스트 스택에 푸시 <br/>
      = 실행 컨텍스트 스택의 최상위 = 실행 중인 실행 컨텍스트
2.  함수 렉시컬 환경 생성

- foo 함수 실행 컨텍스트에 바인딩

  2.1. 함수 환경 레코드 생성

  - 매개변수, arguments 객체, 함수 내부에서 선언한 지역 변수와 중첩 함수 등록 / 관리

    2.2. this 바인딩

  - 함수 환경 레코드 `[[ThisValue]]` 내부 슬롯에 this 바인딩 - 일반 함수로 호출되면 this는 전역 객체를 가리킴 → `[[ThisValue]]` 내부 슬롯엔 전역 객체 바인딩됨 - foo 함수 내부에서 this 참조 → `[[ThisValue]]` 내부 슬롯에 바인딩되어 있는 객체 반환

    2.3. 외부 렉시컬 환경에 대한 참조 결정

  - 실행 컨텍스트의 렉시컬 환경 참조가 할당됨
  - foo 함수는 전역 코드에 정의된 전역 함수 ⇒ 전역 코드 평가 시점에 평가됨
    - 이 시점의 실행 중인 실행 컨텍스트 = 전역 실행 컨텍스트 <br/>
      ⇒ 외부 렉시컬 환경에 대한 참조엔 전역 렉시컬 환경의 참조가 할당됨

👀 JS는 함수를 어디에 정의했는지에 따라 상위 스코프를 결정함 / 함수 객체는 자신이 정의된 스코프인 상위 스코프를 기억함

- JS엔진은 함수 정의 평가 → 함수 객체 생성시 현재 실행 중인 실행 컨텍스트의 렉시컬 환경인 함수 상위 스코프를 함수 객체 내부 슬롯 `[[Environment]]`에 저장
- 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 할당되는 것 <br/>
  = 함수 상위 스코프를 가리키는 함수 객체 내부 슬롯 `[[Environment]]`에 저장된 렉시컬 환경의 참조 <br/>
  ⇒ 함수 객체의 내부 슬롯 `[[Environment]]` 가 렉시컬 스코프를 구현하는 메커니즘!

### 🔸 23.6.5_foo 함수 코드 실행

- 식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자 검색 시작
- 만약 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자 검색이 불가하다면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경으로 이동하여 식별자 검색
  - 모든 식별자는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 모두 검색 가능
  - 검색된 식별자에 값 바인딩

### 🔸 23.6.6_bar 함수 코드 평가

### 🔸 23.6.7_bar 함수 코드 실행

1. console 식별자 검색
   - console 식별자를 스코프 체인에서 검색
     - 스코프 체인 - <u>현재 실행 중인 실행 컨텍스트의 렉시컬 환경 ~ 외부 렉시컬 환경에 대한 참조</u>로 이어지는 렉시컬 환경의 연속 <br/>
       ⇒ 식별자 검색시 항상 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 검색 시작
2. log 메서드 검색
   - console 식별자에 바인딩된 객체인 console 객체에서 log 메서드 검색
     - console 객체의 프로토타입 체인을 통해 메서드 검색
     - log 메서드 - console 객체가 직접 소유하는 프로퍼티
       ```jsx
       console.hasOwnPropert("log"); // true
       ```
3. 표현식 a+b+x+y+z의 평가
   - console.log 메서드에 전달할 인수의 식별자 검색
     - 식별자 - 스코프 체인에서 검색
4. console.log 메서드 호출
   - 표현식이 평가되어 생성한 값을 console.log 메서드에 전달하여 호출

### 🔸 23.6.8_bar 함수 코드 실행 종료

- 렉시컬 환경은 실행 컨텍스트에 의해 참조되긴 하지만 독립적인 객체
- 객체를 포함한 모든 값은 누군가에 의해 참조되지 않을 때 가비지 컬렉터에 의해 메모리 공간 확보 해제 → 소멸
- 만약 함수 실행 컨텍스트가 소멸되어도 함수 렉시컬 환경을 누군가 참조하고 있다면 함수 렉시컬 환경은 소멸하지 않음

### 🔸 23.6.9_foo 함수 코드 실행 종료

### 🔸 23.6.10\_전역 코드 실행 종료

<br/>

## ✅ 23.7\_실행 컨텍스트와 블록 레벨 스코프

- `var`로 선언한 변수는 함수의 코드 블록만 지역 스코프로 인정하는 <u>함수 레벨</u> 스코프를 따름
- `let`, `const`로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 <u>블록 레벨</u> 스코프를 따름

```jsx
let x = 1;

if (true) {
  // if문 코드 블록을 위한 블록 레벨 스코프 생성해야 함
  // 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성 -> 기존 전역 렉시컬 환경 교체
  // 렉시컬 환경의 외부 렉시컬 환경에 대한 참조 - if문 실행 이전 전역 렉시컬 환경을 가리킴
  let x = 10;
  console.log(x); // 10
}

console.log(x); // 1
```

- 코드 블록 실행 종료 → 코드 블록 실행 이전 렉시컬 환경으로 되돌림
- 함수 상위 스코프는 코드 블록이 반복 실행될 때마다 식별자의 값을 유지해야 함
  - 코드 블록 반복 실행될 때마다 독립적인 렉시컬 환경을 생성하여 식별자 값 유지
